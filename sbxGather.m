function result = sbxGather(Info, Parameters)

    %SBXGATHER Gather volumetric scanning data into single planes via maximum intensity projection.
    %   result = SBXGATHER(Info, Parameters) gathers volumetric scanning data and saves it as a new .sbx and .mat files with a maximum intensity projection frame for each scanning plane.
    %
    %   Info: structure 
    %       Info structure generated by sbxInfo from corresponding .mat file.
    %
    %   Parameters: structure
    %       Optional input containing parameter specifications.
    %
    %   result: string
    %       Used by sbxAnalysis to confirm if function ran correctly or was cancelled.
    
    if ~exist('Info', 'var')
        try
            [sbxName, sbxPath] = uigetfile('.sbx', 'Please select file containing imaging data.');
        catch
            waitfor(msgbox('Error: Please select valid .sbx file.'));
            error('Please select valid .sbx file.');
        end
    
        % pull off the file extension
        sbxName = strtok(sbxName, '.');

        Info = sbxInfo([sbxPath, sbxName]);
    end
        
    if Info.volscan == 0
        waitfor(msgbox('Error: Data does not contain volumetric scans.'));
        error('Data does not contain volumetric scans.');
    end

    if isfield(Info, 'gathered') && Info.gathered
        waitfor(msgbox('Error: Data has already been gathered.'));
        error('Data has already been gathered.');
    end
    
    % set the frame offset for when actual volumetric scanning began; adjust this till the first frame corresponds to the first scan of a full scanning waveform
    if ~exist('Parameters', 'var')
        GUI = false;
        
        % set the pixel intensity value to use as a threshold for selecting reference frames
        threshold = 0;
        
        % set sigma of Gaussian filter applied to image to smooth out pixel artefacts - 0 is no filtering
        gaussianFilter = 0.0;
        
        % set the number of consecutive times to motion correct
        passes = 3;
        
        % set number of (random) frames to use in generating a reference image
        sampleSize = 1000;
        
        % specify cropping in pixels: [from left, from right, from top, from bottom]
        frameCrop = [0, 0, 0, 0];
        
        % specify upsampling factor
        subpixelFactor = 1;
    else
        if ~isfield(Parameters, 'GUI')
            GUI = false;
        else
            GUI = Parameters.GUI;
        end
        if ~isfield(Parameters, 'threshold')
            threshold = 0;
        else
            threshold = Parameters.threshold;
        end
        if ~isfield(Parameters, 'gaussianFilter')
            gaussianFilter = 0.0;
        else
            gaussianFilter = Parameters.gaussianFilter;
        end
        if ~isfield(Parameters, 'passes')
            passes = 3;
        else
            passes = Parameters.passes;
        end
        if ~isfield(Parameters, 'sampleSize')
            sampleSize = 1000;
        else
            sampleSize = Parameters.sampleSize;
        end
        if ~isfield(Parameters, 'frameCrop')
            frameCrop = [0, 0, 0, 0];
        else
            frameCrop = Parameters.frameCrop;
        end
        if ~isfield(Parameters, 'subpixelFactor')
            subpixelFactor = 1;
        else
            subpixelFactor = Parameters.subpixelFactor;
        end
        if ~isfield(Parameters, 'align_chan')
            align_chan = 1;
        else
            align_chan = Parameters.align_chan;
        end
    end
    
    % get the number and order of scanning planes
    if ~isempty(Info.otwave_um)
        scanningOrder = Info.otwave_um;
    else
        scanningOrder = Info.otwave;
    end
    
    nScans = length(scanningOrder);
    planes = unique(scanningOrder);
    nPlanes = length(planes);
    
    % get rid of the first period - there are always artefacts there
    volumetricOffset = nScans;
    
    for s = 1:nScans
        for p = 1:nPlanes
            if scanningOrder(s) == planes(p)
                scanningOrder(s) = p;
                break
            end
        end
    end
    
    info = importdata([Info.Directory.folder, Info.Directory.name, '.mat']);

    % indicate that .sbx file has been gathered and how it was done
    info.gathered = 1;
    info.scanningOrder = scanningOrder;
    
    % also, the size has to be updated
    info.sz = [Info.sz(1) - frameCrop(3) - frameCrop(4), Info.sz(2) - frameCrop(1) - frameCrop(2)];
    
    % make this its own thing so the parfor loop can run
    imageSize = info.sz;
    
    framesPerPlane = zeros(1, nPlanes - 1);
%     samplesPerPlane = info.sz(1)*info.sz(2)*Info.nChannels;
    samplesPerPlane = info.sz(1)*info.sz(2)*1;
    
    maxProjections = zeros(nPlanes - 1, samplesPerPlane);
    meanImages = zeros(nPlanes - 1, samplesPerPlane);
        
    if GUI
        progressBar = waitbar(0, 'Gathering volumetric scans...', 'Name', [Info.Directory.name, ': sbxGather'], 'CreateCancelBtn', 'setappdata(gcbf, ''Canceling'', 1)');
        setappdata(progressBar, 'Canceling', 0);
    end
    
    originalSampleSize = sampleSize;
    
    % don't use the first plane - it always has some jitter from the optotune
     parfor p = 2:nPlanes
% 	 for p = 2:nPlanes
        framesForReference = [];
        framesToGather = [];
        
        % collect frame indices corresponding to the current scanning plane +/- 3 planes
        for i = volumetricOffset:Info.maxIndex
           if ismember(scanningOrder(mod(i, nScans) + 1), p - 3:p + 3)
               framesForReference(end + 1) = i;
               
               if scanningOrder(mod(i, nScans) + 1) == p
                   framesToGather(end + 1) = i;
               end
           end               
        end
    
        if originalSampleSize > length(framesForReference)
            sampleSize = length(framesForReference);
        else
            sampleSize = originalSampleSize;
        end
        
        reference = zeros(imageSize);
         
        for pass = 1:passes + 1
            framePool = framesForReference;

            temp = zeros(imageSize);
            
            f = 1;

            % first generate the references
            while f <= sampleSize
                index = randi(length(framesForReference));
                index = framesForReference(index);
            
                if ismember(index, framePool)
                    frame_all_channels = sbxRead(Info, index);
                    num_channels = ndims(frame_all_channels);
                    if num_channels > 2
                        frame = squeeze(frame_all_channels(align_chan,:,:));
                    else
                        frame = frame_all_channels;
                    end
                    %frame = sbxRead(Info, index);
                    
                    
                    if max(frame(:)) > threshold
                    
                        % remove frame from frame pool to keep each index unique
                        framePool(framePool == index) = [];

                        if any(frameCrop > 0)
                            frame = frame(frameCrop(3) + 1:Info.sz(1) - frameCrop(4), frameCrop(1) + 1:Info.sz(2) - frameCrop(2));
                        end

                        if gaussianFilter > 0
                            frame = imgaussfilt(frame, gaussianFilter);
                        end

                        if pass > 1
                            [~, registeredFrame] = dftregistration(fft2(reference), fft2(frame), subpixelFactor);

                            registeredFrame = abs(ifft2(registeredFrame));

                            % adjust values just in case
                            originalMinimum = double(min(frame(:)));
                            originalMaximum = double(max(frame(:)));
                            registeredMinimum = min(registeredFrame(:));
                            registeredMaximum = max(registeredFrame(:));

                            frame = (registeredFrame - registeredMinimum)/(registeredMaximum - registeredMinimum)*(originalMaximum - originalMinimum) + originalMinimum;
                        end

                        temp = max(temp, double(frame));
                        
                        f = f + 1;
                    else
                        % if frame doesn't have anything above threshold, then remove it from the framePool
                        framePool(framePool == index) = [];
                    end
                end
            
                if isempty(framePool)
                    warning(['Only ', int2str(f - 1), ' frames exceeded pixel intensity threshold.']);
                    break
                end
            end

            reference = uint16(temp);

            % on the last pass, register each frame
            if pass == passes + 1
                registeredFrames = zeros(length(framesToGather), imageSize(1), imageSize(2));
                
                for f = 1:length(framesToGather)
                    % frame = sbxRead(Info, framesToGather(f));
                    
                    frame_all_channels = sbxRead(Info, framesToGather(f));
                    num_channels = ndims(frame_all_channels);
                    if num_channels > 2
                        frame = squeeze(frame_all_channels(align_chan,:,:));
                    else
                        frame = frame_all_channels;
                    end

                    if any(frameCrop > 0)
                        frame = frame(frameCrop(3) + 1:Info.sz(1) - frameCrop(4), frameCrop(1) + 1:Info.sz(2) - frameCrop(2));
                    end

                    if gaussianFilter > 0
                        smoothedFrame = imgaussfilt(frame, gaussianFilter);
                        
                        [temp, ~] = dftregistration(fft2(reference), fft2(smoothedFrame), subpixelFactor);
                    else
                        [temp, ~] = dftregistration(fft2(reference), fft2(frame), subpixelFactor);
                    end
                    
                    phaseDifference = temp(2);
                    rowShift = temp(3);
                    columnShift = temp(4);

                    if phaseDifference ~= 0 || rowShift ~= 0 || columnShift ~= 0
                        registeredFrame = fft2(frame);

                        [numberOfRows, numberOfColumns] = size(registeredFrame);
                        Nr = ifftshift(-fix(numberOfRows/2):ceil(numberOfRows/2) - 1);
                        Nc = ifftshift(-fix(numberOfColumns/2):ceil(numberOfColumns/2) - 1);
                        [Nc, Nr] = meshgrid(Nc, Nr);

                        registeredFrame = registeredFrame.*exp(2i*pi*(-rowShift*Nr/numberOfRows - columnShift*Nc/numberOfColumns));
                        registeredFrame = registeredFrame*exp(1i*phaseDifference);

                        registeredFrame = abs(ifft2(registeredFrame));

                        % adjust values just in case
                        originalMinimum = double(min(frame(:)));
                        originalMaximum = double(max(frame(:)));
                        adjustedMinimum = min(registeredFrame(:));
                        adjustedMaximum = max(registeredFrame(:));

                        registeredFrame = uint16((registeredFrame - adjustedMinimum)/(adjustedMaximum - adjustedMinimum)*(originalMaximum - originalMinimum) + originalMinimum);
                    else
                        registeredFrame = frame;
                    end

                    registeredFrames(f, :, :) = registeredFrame;
                end
                    
                meanImage = uint16(squeeze(mean(registeredFrames, 1)));
                maxProjection = uint16(squeeze(prctile(registeredFrames, 95, 1)));

                % reshape the data into its original, pure form
                if Info.nChannels > 100
                    meanImage = permute(intmax('uint16') - meanImage, [1, 3, 2]);
                    maxProjection = permute(intmax('uint16') - maxProjection, [1, 3, 2]);
                else
                    meanImage = permute(intmax('uint16') - meanImage, [2, 1]);
                    maxProjection = permute(intmax('uint16') - maxProjection, [2, 1]);
                end

                % make sure to use the updated number of samples per frame
                meanImages(p - 1, :) = reshape(meanImage, [samplesPerPlane, 1]);
                maxProjections(p - 1, :) = reshape(maxProjection, [samplesPerPlane, 1]);

                framesPerPlane(p - 1) = length(framesToGather);
            end
        end
    end
    
    info.framesPerPlane = framesPerPlane;
    
    fileName = [Info.Directory.folder, Info.Directory.name, '_gathered'];
    
    if exist([fileName, '.sbx'], 'file')
        choice = questdlg('Override old gathered z-stack? If not, data will be saved to new file.', 'sbxGather', 'Yes', 'No', 'No');

        if strcmp(choice, 'No')
            number = 1;

            while exist([fileName, '_', int2str(number), '.sbx'], 'file')
                number = number + 1;
            end

            fileName = [fileName, '_', int2str(number)];
        end
    end
    
    newFileID = fopen([fileName, '.sbx'], 'w');
    
    for p = 1:nPlanes - 1
        fwrite(newFileID, uint16(meanImages(p, :).'), 'uint16');
    end
    
    for p = 1:nPlanes - 1
        fwrite(newFileID, uint16(maxProjections(p, :).'), 'uint16');
    end
    
    info.channels = 2; % set channels to 2 (which indicates that only one channel was recorded) since only one channel gets gathered at a time
    save([Info.Directory.folder, Info.Directory.name, '_gathered.mat'], 'info');

    fclose(newFileID);
    
    if GUI
        delete(progressBar);
    end
    
    result = 'Completed';

end